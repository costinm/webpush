syntax = "proto3";
package webpush;

option go_package = "github.com/costinm/wpgate/pkg/msgs";

// A DiscoveryRequest requests a set of versioned resources of the same type for
// a given Envoy node on some API.
message DiscoveryRequest {
    // The version_info provided in the request messages will be the version_info
    // received with the most recent successfully processed response or empty on
    // the first request. It is expected that no new request is sent after a
    // response is received until the Envoy instance is ready to ACK/NACK the new
    // configuration. ACK/NACK takes place by returning the new API config version
    // as applied or the previous API config version respectively. Each type_url
    // (see below) has an independent version associated with it.
    string version_info = 1;

    // node not used

    // List of resources to subscribe to, e.g. list of cluster names or a route
    // configuration name. If this is empty, all resources for the API are
    // returned. LDS/CDS expect empty resource_names, since this is global
    // discovery for the Envoy instance. The LDS and CDS responses will then imply
    // a number of resources that need to be fetched via EDS/RDS, which will be
    // explicitly enumerated in resource_names.
    repeated string resource_names = 3;

    // Type of the resource that is being requested, e.g.
    // "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
    // in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
    // required for ADS.
    string type_url = 4;

    // nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
    // discussion on version_info and the DiscoveryResponse nonce comment. This
    // may be empty if no nonce is available, e.g. at startup or for non-stream
    // xDS implementations.
    string response_nonce = 5;

    // The response resources. These resources are typed and depend on the API being called.
    // google.protobuf.Any
    repeated Any resources = 7;
}

message DiscoveryResponse {
    // The version of the response data.
    string version_info = 1;

    // The response resources. These resources are typed and depend on the API being called.
    // google.protobuf.Any
    repeated Any resources = 2;

    // Type URL for resources. This must be consistent with the type_url in the
    // Any messages for resources if resources is non-empty. This effectively
    // identifies the xDS API when muxing over ADS.
    string type_url = 4;

    // For gRPC based subscriptions, the nonce provides a way to explicitly ack a
    // specific DiscoveryResponse in a following DiscoveryRequest. Additional
    // messages may have been sent by Envoy to the management server for the
    // previous version on the stream prior to this DiscoveryResponse, that were
    // unprocessed at response send time. The nonce allows the management server
    // to ignore any further DiscoveryRequests for the previous version until a
    // DiscoveryRequest bearing the nonce. The nonce is optional and is not
    // required for non-stream based xDS implementations.
    string nonce = 5;
}

// Webpush is a GRPC mapping of the webpush protocol. While webpush is defined using
// Push promise, it is a bit tricky to support with many stacks today. As an alternative,
// it can be mapped to any bi-directional streaming protocol, like gRPC or SSH or plain socket.
//
// The stream protocol must define a framing/encapsulation mechansim - in case of gRPC, the message could
// be encoded as Any in a wrapper. For raw protocols, a TLV or len-prefix can be used.
//
// Control messages can be sent on the wire as regular webpush messages,
// including Receipts, Acks, SubscibeRequests/Responses.

// XDS mapping.
// Envoy XDS and UDPA define a generic transport for 'resources'.
// Webpush is mapped to XDS:
// - 'monitor' and 'receipt' stream correspond to aggregated Request and matching Response
// - Subscribe and message sending are mapped to separate Request/Response pairs.

// Copied to avoid dependency. type_url format: prefix/message.type
message Any {
    string type_url = 1;
    bytes value = 2;
}

// Message is returned as PUSH PROMISE frames in the spec. The alternative protocol wraps it in
// Any field or other framing.
message MessageEnvelope {

    string message_id = 1;

    // Maps to the SubscribeResponse push parameter, returned as Link rel="urn:ietf:params:push"
    // in the push promise.
    string push = 2;

    // If 'dh' and 'salt' are set, will contain encrypted data.
    // Otherwise it is a plaintext message.
    bytes data = 3;

    // Identifies the sender.
    Vapid sender = 4;

    string content_encoding = 7;

    bytes salt = 8;

    bytes dh = 9;
}

// Vapid is the proto variant of a Webpush JWT.
//
// For HTTP, included in Authorization header:
// Authorization: vapid t=B64url k=B64url
//
// Decoded t is of form: { "typ": "JWT", "alg": "ES256" }.JWT.SIG
//
// { "crv":"P-256",
//   "kty":"EC",
//   "x":"DUfHPKLVFQzVvnCPGyfucbECzPDa7rWbXriLcysAjEc",
//   "y":"F6YK5h4SDYic-dRuU_RCPCfA5aq9ojSwk5Y2EmClBPs" }
message Vapid {
    // json payload of VAPID ( without base64 encoding)
    // Can also be a proto message when used over other transports.
    // Verification requires converting back to base64 !
    // We decode to reduce the binary size
    bytes data = 7;

    // Public key of the signer, 64 bytes, EC256.
    // Included in 'k' parameter for HTTP.
    bytes k = 4;

    // If empty, it is assumed to be the constant value {typ=JWT,alg=ES256}
    bytes t_type = 32;

    bytes t_signature = 33;
}

//
message SubscribeRequest {

    // A UA should group subscriptions in a set. First request from a
    // UA will not include a set - it is typically a subscription associated with
    // the UA itself.
    string push_set = 1;

    // Included as Crypto-Key: p256ecdsa parameter.
    // Corresponds to the applicationServerKey parameter in the PushSubscriptionOptions in
    // the W3C API
    string sender_vapid = 2;
}

// Subscribe response includes the elements in the spec.
message SubscribeResponse {
    // Returned as Link: rel="urn:ietf:params:push"
    // Spec examples use a full path ( /push/xxxx1 )
    // TODO: clarify if it can be a full URL
    string push = 1;

    // Optional response: it
    // returned as Link: rel=urn:ietf:params:push:set
    // Spec examples use a full path ( /subscription-set/xxxx2 ).
    // TODO: clarify it can be a full URL, like subscription
    string push_set = 2;

    // Push subscription resource. This is the full URL where the UA will use to
    // receive the messages, using the PUSH promise http2 frame.
    //
    //
    // Returned as Location header in the spec
    string location = 3;
}

message PushRequest {

    // The value returned in the SubscribeResponse push, without the hostname.
    string push = 1;
    int32 ttl = 2;

    bytes data = 3;

    string urgency = 4;

    // Prefer header indicating delivery receipt request.
    bool respond_async = 5;

    string topic = 6;

    string content_encoding = 7;

    string salt = 8;

    string dh = 9;
}

message PushResponse {
  string message_id = 1;

  // If request includes the respond_async parameter.
  //
  string push_receipt = 2;
}

message MonitorRequest {
    // This is the push or push_set in the subscribe response.
    string push_set = 1;

    // JWT token, signed with key
    string authorization = 2;

    // Public key used for signing, identifies sender/receiver
    string key = 3;
}

message AckRequest {
    string message_id = 1;

    // Optional, not part of the spec: if the subscribe request was authenticated with VAPID,
    // the delete should also be authenticated with same VAPID key
}

message AckResponse {
}

message ReceiptRequest {
    string receipt_subscription = 1;
}

message Receipt {
    string message_id = 1;
}

// Not implemented - alternative interface with explicit methos for each operation.
//service Webpush {
//    // Subscribe maps the the webpush subscribe request
//    rpc Subscribe (SubscribeRequest) returns (SubscribeResponse) {
//    }
//
//    // Monitor allows a UA to receive push messages from the push service
//    // Replaced push promises with a stream of Message objects.
//    rpc Monitor(MonitorRequest) returns (stream Message) {}
//
//    rpc Ack(AckRequest) returns (AckResponse) {}
//
//    // Push allows an application server to send messages to UA, using the push service.
//    rpc Push(PushRequest) returns (PushResponse) {}
//
//    // Monitor allows an AS to receive push messages receipts from the push service
//    // Replaced push promises with a stream of Message objects.
//    rpc Receipts(ReceiptRequest) returns (stream Receipt) {}
//}

