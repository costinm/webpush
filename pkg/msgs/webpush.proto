syntax = "proto3";
package webpush;

option go_package="github.com/costinm/wpgate/pkg/msgs";

// Webpush is a GRPC mapping of the webpush protocol. While webpush is defined using
// Push promise, it is a bit tricky to support with many stacks today. As an alternative,
// it can be mapped to any bi-directional streaming protocol, like gRPC or SSH or plain socket.
//
// The stream protocol must define a framing/encapsulation mechansim - in case of gRPC, the message could
// be encoded as Any in a wrapper. For raw protocols, a TLV or len-prefix can be used.
//
// Control messages can be sent on the wire as regular webpush messages,
// including Receipts, Acks, SubscibeRequests/Responses.

// XDS mapping.
// Envoy XDS and UDPA define a generic transport for 'resources'.
// Webpush is mapped to XDS:
// - 'monitor' and 'receipt' stream correspond to aggregated Request and matching Response
// - Subscribe and message sending are mapped to separate Request/Response pairs.

// Copied to avoid dependency. type_url format: prefix/message.type
message Any {
    string type_url = 1;
    bytes value = 2;
}

// Message is returned as PUSH PROMISE frames in the spec. The alternative protocol wraps it in
// Any field or other framing.
message MessageEnvelope {

    string message_id = 1;

    // Maps to the SubscribeResponse push parameter, returned as Link rel="urn:ietf:params:push"
    // in the push promise.
    string push = 2;

    // If 'dh' and 'salt' are set, will contain encrypted data.
    // Otherwise it is a plaintext message.
    bytes data = 3;

    // Identifies the sender.
    Vapid sender = 4;

    string content_encoding = 7;

    bytes salt = 8;

    bytes dh = 9;
}

// Vapid is the proto variant of a Webpush JWT.
//
// For HTTP, included in Authorization header:
// Authorization: vapid t=B64url k=B64url
//
// Decoded t is of form: { "typ": "JWT", "alg": "ES256" }
//
// { "crv":"P-256",
//   "kty":"EC",
//   "x":"DUfHPKLVFQzVvnCPGyfucbECzPDa7rWbXriLcysAjEc",
//   "y":"F6YK5h4SDYic-dRuU_RCPCfA5aq9ojSwk5Y2EmClBPs" }
message Vapid {

//    string aud = 1;
//
//    // Default: 24h
//    uint64 exp = 2;
//
//    string sub = 3;

    // json payload of VAPID ( without base64 encoding)
    // Can also be a proto message when used over other transports.
    bytes data = 7;

    // Public key of the signer, 64 bytes, EC256.
    // Included in 'k' parameter for HTTP.
    bytes k = 4;

    // If empty, it is assumed to be the constant value {typ=JWT,alg=ES256}
    bytes t_type = 32;

    // If empty, signatureX and signatureY will be used, with the constant prefix
    // This reduces the size of the packet when in binary - verification is still over
    // JSON format
    bytes t_signature = 33;

    bytes signatureX = 5;

    bytes signatureY = 6;
}

//
message SubscribeRequest {

    // A UA should group subscriptions in a set. First request from a
    // UA will not include a set - it is typically a subscription associated with
    // the UA itself.
    string push_set = 1;

    // Included as Crypto-Key: p256ecdsa parameter.
    // Corresponds to the applicationServerKey parameter in the PushSubscriptionOptions in
    // the W3C API
    string sender_vapid = 2;
}

// Subscribe response includes the elements in the spec.
message SubscribeResponse {
    // Returned as Link: rel="urn:ietf:params:push"
    // Spec examples use a full path ( /push/xxxx1 )
    // TODO: clarify if it can be a full URL
    string push = 1;

    // Optional response: it
    // returned as Link: rel=urn:ietf:params:push:set
    // Spec examples use a full path ( /subscription-set/xxxx2 ).
    // TODO: clarify it can be a full URL, like subscription
    string push_set = 2;

    // Push subscription resource. This is the full URL where the UA will use to
    // receive the messages, using the PUSH promise http2 frame.
    //
    //
    // Returned as Location header in the spec
    string location = 3;
}

message PushRequest {

    // The value returned in the SubscribeResponse push, without the hostname.
    string push = 1;
    int32 ttl = 2;

    bytes data = 3;

    string urgency = 4;

    // Prefer header indicating delivery receipt request.
    bool respond_async = 5;

    string topic = 6;

    string content_encoding = 7;

    string salt = 8;

    string dh = 9;
}

message PushResponse {
  string message_id = 1;

  // If request includes the respond_async parameter.
  //
  string push_receipt = 2;

}

message MonitorRequest {
    // This is the push or push_set in the subscribe response.
    string push_set = 1;

    // JWT token, signed with key
    string authorization = 2;

    // Public key used for signing, identifies sender/receiver
    string key = 3;
}

message AckRequest {
    string message_id = 1;

    // Optional, not part of the spec: if the subscribe request was authenticated with VAPID,
    // the delete should also be authenticated with same VAPID key
}

message AckResponse {
}

message ReceiptRequest {
    string receipt_subscription = 1;
}

message Receipt {
    string message_id = 1;
}

// Not implemented - alternative interface with explicit methos for each operation.
//service Webpush {
//    // Subscribe maps the the webpush subscribe request
//    rpc Subscribe (SubscribeRequest) returns (SubscribeResponse) {
//    }
//
//    // Monitor allows a UA to receive push messages from the push service
//    // Replaced push promises with a stream of Message objects.
//    rpc Monitor(MonitorRequest) returns (stream Message) {}
//
//    rpc Ack(AckRequest) returns (AckResponse) {}
//
//    // Push allows an application server to send messages to UA, using the push service.
//    rpc Push(PushRequest) returns (PushResponse) {}
//
//    // Monitor allows an AS to receive push messages receipts from the push service
//    // Replaced push promises with a stream of Message objects.
//    rpc Receipts(ReceiptRequest) returns (stream Receipt) {}
//}

