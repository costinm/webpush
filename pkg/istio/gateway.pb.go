// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/costinm/dmesh/dm/istio/gateway.proto

package istio

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TLS modes enforced by the proxy
type Server_TLSOptions_TLSmode int32

const (
	// ReverseForward the connection to the upstream server selected based on
	// the SNI string presented by the client.
	Server_TLSOptions_PASSTHROUGH Server_TLSOptions_TLSmode = 0
	// Secure connections with standard TLS semantics.
	Server_TLSOptions_SIMPLE Server_TLSOptions_TLSmode = 1
	// Secure connections to the upstream using mutual TLS by presenting
	// client certificates for authentication.
	Server_TLSOptions_MUTUAL Server_TLSOptions_TLSmode = 2
)

var Server_TLSOptions_TLSmode_name = map[int32]string{
	0: "PASSTHROUGH",
	1: "SIMPLE",
	2: "MUTUAL",
}
var Server_TLSOptions_TLSmode_value = map[string]int32{
	"PASSTHROUGH": 0,
	"SIMPLE":      1,
	"MUTUAL":      2,
}

func (x Server_TLSOptions_TLSmode) String() string {
	return proto.EnumName(Server_TLSOptions_TLSmode_name, int32(x))
}
func (Server_TLSOptions_TLSmode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGateway, []int{1, 0, 0}
}

// `Gateway` describes a load balancer operating at the edge of the mesh
// receiving incoming or outgoing HTTP/TCP connections. The specification
// describes a set of ports that should be exposed, the type of protocol to
// use, SNI configuration for the load balancer, etc.
//
// For example, the following Gateway configuration sets up a proxy to act
// as a load balancer exposing port 80 and 9080 (http), 443 (https), and
// port 2379 (TCP) for ingress.  The gateway will be applied to the proxy
// running on a pod with labels `app: my-gateway-controller`. While Istio
// will configure the proxy to listen on these ports, it is the
// responsibility of the user to ensure that external traffic to these
// ports are allowed into the mesh.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: Gateway
//     metadata:
//       name: my-gateway
//     spec:
//       selector:
//         app: my-gatweway-controller
//       servers:
//       - port:
//           number: 80
//           name: http
//           protocol: HTTP
//         hosts:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//         tls:
//           httpsRedirect: true # sends 302 redirect for http requests
//       - port:
//           number: 443
//           name: https
//           protocol: HTTPS
//         hosts:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//         tls:
//           mode: SIMPLE #enables HTTPS on this port
//           serverCertificate: /etc/certs/servercert.pem
//           privateKey: /etc/certs/privatekey.pem
//       - port:
//           number: 9080
//           name: http-wildcard
//           protocol: HTTP
//         # no hosts implies wildcard match
//       - port:
//           number: 2379 #to expose internal service via external port 2379
//           name: mongo
//           protocol: MONGO
//
// The Gateway specification above describes the L4-L6 properties of a load
// balancer. A `VirtualService` can then be bound to a gateway to control
// the forwarding of traffic arriving at a particular host or gateway port.
//
// For example, the following VirtualService splits traffic for
// "https://uk.bookinfo.com/reviews", "https://eu.bookinfo.com/reviews",
// "http://uk.bookinfo.com:9080/reviews",
// "http://eu.bookinfo.com:9080/reviews" into two versions (prod and qa) of
// an internal reviews service on port 9080. In addition, requests
// containing the cookie "user: dev-123" will be sent to special port 7777
// in the qa version. The same rule is also applicable inside the mesh for
// requests to the r"eviews.prod.svc.cluster.local" service. This rule is
// applicable across ports 443, 9080. Note that "http://uk.bookinfo.com"
// gets redirected to "https://uk.bookinfo.com" (i.e. 80 redirects to 443).
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: VirtualService
//     metadata:
//       name: bookinfo-rule
//     spec:
//       hosts:
//       - reviews.prod.svc.cluster.local
//       - uk.bookinfo.com
//       - eu.bookinfo.com
//       gateways:
//       - my-gateway
//       - mesh # applies to all the sidecars in the mesh
//       http:
//       - match:
//         - headers:
//             cookie:
//               user: dev-123
//         route:
//         - destination:
//             port:
//               number: 7777
//             name: reviews.qa.svc.cluster.local
//       - match:
//           uri:
//             prefix: /reviews/
//         route:
//         - destination:
//             port:
//               number: 9080 # can be omitted if its the only port for reviews
//             name: reviews.prod.svc.cluster.local
//           weight: 80
//         - destination:
//             name: reviews.qa.svc.cluster.local
//           weight: 20
//
// The following VirtualService forwards traffic arriving at (external)
// port 27017 from "172.17.16.0/24" subnet to internal Mongo server on port
// 5555. This rule is not applicable internally in the mesh as the gateway
// list omits the reserved name `mesh`.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: VirtualService
//     metadata:
//       name: bookinfo-Mongo
//     spec:
//       hosts:
//       - mongosvr.prod.svc.cluster.local #name of internal Mongo service
//       gateways:
//       - my-gateway
//       tcp:
//       - match:
//         - port:
//             number: 27017
//           sourceSubnet: "172.17.16.0/24"
//         route:
//         - destination:
//             name: mongo.prod.svc.cluster.local
//
type Gateway struct {
	// REQUIRED: A list of server specifications.
	Servers []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
	// One or more labels that indicate a specific set of pods/VMs
	// on which this gateway configuration should be applied.
	Selector map[string]string `protobuf:"bytes,2,rep,name=selector" json:"selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Gateway) Reset()                    { *m = Gateway{} }
func (m *Gateway) String() string            { return proto.CompactTextString(m) }
func (*Gateway) ProtoMessage()               {}
func (*Gateway) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{0} }

func (m *Gateway) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *Gateway) GetSelector() map[string]string {
	if m != nil {
		return m.Selector
	}
	return nil
}

// `Server` describes the properties of the proxy on a given load balancer
// port. For example,
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: Gateway
//     metadata:
//       name: my-ingress
//     spec:
//       selector:
//         app: my-ingress-gateway
//       servers:
//       - port:
//           number: 80
//           name: http2
//           protocol: HTTP2
//
// Another example
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: Gateway
//     metadata:
//       name: my-tcp-ingress
//     spec:
//       selector:
//         app: my-tcp-ingress-gateway
//       servers:
//       - port:
//           number: 27018
//           name: mongo
//           protocol: MONGO
//
// The following is an example of TLS configuration for port 443
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: Gateway
//     metadata:
//       name: my-tls-ingress
//     spec:
//       selector:
//         app: my-tls-ingress-gateway
//       servers:
//       - port:
//           number: 443
//           name: https
//           protocol: HTTPS
//         tls:
//           mode: SIMPLE
//           serverCertificate: /etc/certs/server.pem
//           privateKey: /etc/certs/privatekey.pem
//
type Server struct {
	// REQUIRED: The Port on which the proxy should listen for incoming
	// connections
	Port *Port `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	// A list of hosts exposed by this gateway. While typically applicable to
	// HTTP services, it can also be used for TCP services using TLS with
	// SNI. Standard DNS wildcard prefix syntax is permitted.
	//
	// **Note**: A `VirtualService` that is bound to a gateway must have one
	// or more hosts that match the hosts specified in a server. The match
	// could be an exact match or a suffix match with the server's hosts. For
	// example, if the server's hosts specifies "*.example.com",
	// VirtualServices with hosts dev.example.com, prod.example.com will
	// match. However, VirtualServices with hosts example.com or
	// newexample.com will not match.
	Hosts []string `protobuf:"bytes,2,rep,name=hosts" json:"hosts,omitempty"`
	// Set of TLS related options that govern the server's behavior. Use
	// these options to control if all http requests should be redirected to
	// https, and the TLS modes to use.
	Tls *Server_TLSOptions `protobuf:"bytes,3,opt,name=tls" json:"tls,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{1} }

func (m *Server) GetPort() *Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *Server) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Server) GetTls() *Server_TLSOptions {
	if m != nil {
		return m.Tls
	}
	return nil
}

type Server_TLSOptions struct {
	// If set to true, the load balancer will send a 302 redirect for all
	// http connections, asking the clients to use HTTPS.
	HttpsRedirect bool `protobuf:"varint,1,opt,name=https_redirect,proto3" json:"https_redirect,omitempty"`
	// Optional: Indicates whether connections to this port should be
	// secured using TLS. The value of this field determines how TLS is
	// enforced.
	Mode Server_TLSOptions_TLSmode `protobuf:"varint,2,opt,name=mode,proto3,enum=istio.Server_TLSOptions_TLSmode" json:"mode,omitempty"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file
	// holding the server-side TLS certificate to use.
	ServerCertificate string `protobuf:"bytes,3,opt,name=server_certificate,proto3" json:"server_certificate,omitempty"`
	// REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file
	// holding the server's private key.
	PrivateKey string `protobuf:"bytes,4,opt,name=private_key,proto3" json:"private_key,omitempty"`
	// REQUIRED if mode is `MUTUAL`. The path to a file containing
	// certificate authority certificates to use in verifying a presented
	// client side certificate.
	CaCertificates string `protobuf:"bytes,5,opt,name=ca_certificates,proto3" json:"ca_certificates,omitempty"`
	// A list of alternate names to verify the subject identity in the
	// certificate presented by the client.
	SubjectAltNames []string `protobuf:"bytes,6,rep,name=subject_alt_names" json:"subject_alt_names,omitempty"`
}

func (m *Server_TLSOptions) Reset()                    { *m = Server_TLSOptions{} }
func (m *Server_TLSOptions) String() string            { return proto.CompactTextString(m) }
func (*Server_TLSOptions) ProtoMessage()               {}
func (*Server_TLSOptions) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{1, 0} }

func (m *Server_TLSOptions) GetHttpsRedirect() bool {
	if m != nil {
		return m.HttpsRedirect
	}
	return false
}

func (m *Server_TLSOptions) GetMode() Server_TLSOptions_TLSmode {
	if m != nil {
		return m.Mode
	}
	return Server_TLSOptions_PASSTHROUGH
}

func (m *Server_TLSOptions) GetServerCertificate() string {
	if m != nil {
		return m.ServerCertificate
	}
	return ""
}

func (m *Server_TLSOptions) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *Server_TLSOptions) GetCaCertificates() string {
	if m != nil {
		return m.CaCertificates
	}
	return ""
}

func (m *Server_TLSOptions) GetSubjectAltNames() []string {
	if m != nil {
		return m.SubjectAltNames
	}
	return nil
}

// Port describes the properties of a specific port of a service.
type Port struct {
	// REQUIRED: A valid non-negative integer port number.
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// REQUIRED: The protocol exposed on the port.
	// MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TCP-TLS.
	// TCP-TLS is used to indicate secure connections to non HTTP services.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Label assigned to the port.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{2} }

func (m *Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*Gateway)(nil), "istio.Gateway")
	proto.RegisterType((*Server)(nil), "istio.Server")
	proto.RegisterType((*Server_TLSOptions)(nil), "istio.Server.TLSOptions")
	proto.RegisterType((*Port)(nil), "istio.Port")
	proto.RegisterEnum("istio.Server_TLSOptions_TLSmode", Server_TLSOptions_TLSmode_name, Server_TLSOptions_TLSmode_value)
}

func init() {
	proto.RegisterFile("github.com/costinm/dmesh/dm/istio/gateway.proto", fileDescriptorGateway)
}

var fileDescriptorGateway = []byte{
	// 418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xd1, 0x8a, 0xd3, 0x40,
	0x14, 0x86, 0x4d, 0x9a, 0xa6, 0xed, 0x89, 0xed, 0xd6, 0x11, 0x34, 0x5b, 0x44, 0x4a, 0x41, 0xd8,
	0xab, 0x04, 0x2a, 0x88, 0x78, 0xb7, 0xc2, 0xb2, 0x2b, 0x74, 0xd9, 0x62, 0xda, 0x1b, 0x6f, 0xc2,
	0x74, 0x7a, 0xdc, 0x8e, 0x26, 0x99, 0x30, 0x73, 0x52, 0xe9, 0x2b, 0xf8, 0x66, 0x3e, 0x8c, 0xef,
	0x20, 0x33, 0x89, 0xe8, 0x5e, 0xec, 0xdd, 0xcc, 0x7f, 0xbe, 0x99, 0xff, 0x3f, 0x87, 0x03, 0xe9,
	0xbd, 0xa4, 0x43, 0xb3, 0x4b, 0x84, 0x2a, 0x53, 0xa1, 0x0c, 0xc9, 0xaa, 0x4c, 0xf7, 0x25, 0x9a,
	0x43, 0xba, 0x2f, 0x53, 0x69, 0x48, 0xaa, 0xf4, 0x9e, 0x13, 0xfe, 0xe0, 0xa7, 0xa4, 0xd6, 0x8a,
	0x14, 0xeb, 0x3b, 0x71, 0xf1, 0xd3, 0x83, 0xc1, 0x75, 0x5b, 0x60, 0xaf, 0x61, 0x60, 0x50, 0x1f,
	0x51, 0x9b, 0xd8, 0x9b, 0xf7, 0x2e, 0xa2, 0xe5, 0x38, 0x71, 0x50, 0x92, 0x39, 0x95, 0x25, 0x30,
	0x34, 0x58, 0xa0, 0x20, 0xa5, 0x63, 0xdf, 0x01, 0xaf, 0x3a, 0xa0, 0xfb, 0x21, 0xc9, 0xba, 0xf2,
	0x55, 0x45, 0xfa, 0x34, 0x4b, 0x61, 0xfc, 0x40, 0x60, 0x11, 0xf4, 0xbe, 0xe3, 0x29, 0xf6, 0xe6,
	0xde, 0xc5, 0x88, 0x8d, 0xa1, 0x7f, 0xe4, 0x45, 0x83, 0xb1, 0x6f, 0xaf, 0x1f, 0xfc, 0xf7, 0xde,
	0xe2, 0x97, 0x0f, 0x61, 0xe7, 0x75, 0x0e, 0x41, 0xad, 0x34, 0x39, 0x36, 0x5a, 0x46, 0x9d, 0xcf,
	0x5a, 0x69, 0xb2, 0x0f, 0x0f, 0xca, 0x90, 0x71, 0x19, 0x46, 0xec, 0x0d, 0xf4, 0xa8, 0x30, 0x71,
	0xcf, 0x81, 0xf1, 0x83, 0xc4, 0xc9, 0x66, 0x95, 0xdd, 0xd5, 0x24, 0x55, 0x65, 0x66, 0xbf, 0x3d,
	0x80, 0x7f, 0x57, 0xf6, 0x02, 0x26, 0x07, 0xa2, 0xda, 0xe4, 0x1a, 0xf7, 0x52, 0xa3, 0x68, 0x9d,
	0x86, 0x2c, 0x81, 0xa0, 0x54, 0xfb, 0x36, 0xd4, 0x64, 0x39, 0x7f, 0xec, 0x3b, 0x7b, 0xb4, 0x1c,
	0x9b, 0x01, 0x6b, 0x67, 0x96, 0x0b, 0xd4, 0x24, 0xbf, 0x4a, 0xc1, 0x09, 0x5d, 0x98, 0x11, 0x7b,
	0x0e, 0x51, 0xad, 0xe5, 0x91, 0x13, 0xe6, 0xb6, 0xed, 0xc0, 0x89, 0x2f, 0xe1, 0x4c, 0xf0, 0xff,
	0x61, 0x13, 0xf7, 0x5d, 0xe1, 0x1c, 0x9e, 0x99, 0x66, 0xf7, 0x0d, 0x05, 0xe5, 0xbc, 0xa0, 0xbc,
	0xe2, 0x25, 0x9a, 0x38, 0xb4, 0x2d, 0x2e, 0x96, 0x30, 0xf8, 0xeb, 0x77, 0x06, 0xd1, 0xfa, 0x32,
	0xcb, 0x36, 0x37, 0x9f, 0xef, 0xb6, 0xd7, 0x37, 0xd3, 0x27, 0x0c, 0x20, 0xcc, 0x3e, 0xdd, 0xae,
	0x57, 0x57, 0x53, 0xcf, 0x9e, 0x6f, 0xb7, 0x9b, 0xed, 0xe5, 0x6a, 0xea, 0x2f, 0xde, 0x41, 0xe0,
	0xa6, 0x35, 0x81, 0xb0, 0x6a, 0xca, 0x1d, 0x6a, 0xd7, 0xe0, 0x98, 0x4d, 0x61, 0xe8, 0x16, 0x40,
	0xa8, 0xa2, 0x9d, 0x3c, 0x7b, 0x0a, 0x81, 0x35, 0x6b, 0x43, 0x7f, 0x1c, 0x7c, 0x69, 0x37, 0x63,
	0x17, 0x3a, 0xec, 0xed, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x21, 0xda, 0x77, 0xd4, 0x5a, 0x02,
	0x00, 0x00,
}
